/*
 *
 * Copyright (c) 2017 Raphine Project
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Author: Liva
 *
 * analyzer for pf2 font file (generated by grub-mkfont)
 * 
 */

#pragma once

#include <assert.h>
#include <ptr.h>
#include <array.h>
#include <string.h>
#include <endian.h>
#include <stdint.h>
#include <mem/physmem.h>

class Font {
public:
  Font() {
  }
  int Load(uptr<Array<uint8_t>> buf, size_t len) {
    _buf = buf;
    char *_buf_ptr = _buf->GetRawPtr();
    if (strncmp("FILE", _buf_ptr, 4) != 0) {
      return -1;
    }
    if (be32toh(*(reinterpret_cast<uint32_t *>(_buf_ptr + 4))) != 4) {
      return -1;
    }
    if (strncmp("PFF2", _buf_ptr + 8, 4) != 0) {
      return -1;
    }

    _maxw.Load(_buf_ptr + 12);
    _maxh.Load(_buf_ptr + 12);
    _data.SetBuffer(_buf_ptr);
    _data.Load(_buf_ptr + 12);
    _chix.Load(_buf_ptr + 12);
    _asce.Load(_buf_ptr + 12);
    _desc.Load(_buf_ptr + 12);
    _is_initialized = true;
    return 0;
  }
  void Print(char32_t c, void (*func)(int x, int y)) {
    if (!_is_initialized) {
      return;
    }

    uint32_t index = _chix.GetIndex(c);
    if (index == 0xFFFFFFFF || _chix.GetStorageFlag(index)) {
      return;
    }
    uint32_t offset = _chix.GetOffset(index);
    int maxh = _maxh.Get();
    
    uint32_t byte_offset = offset + 10;
    uint32_t bit_offset = 7;
    int bitmap_bottom = _asce.Get() - _data.GetYOffset(offset);
    int bitmap_top = bitmap_bottom - _data.GetHeight(offset);
    int bitmap_left = _data.GetXOffset(offset);
    int bitmap_right = _data.GetXOffset(offset) + _data.GetWidth(offset);
    int width = _data.GetDeviceWidth(offset);

    for (int y = bitmap_top; y < bitmap_bottom; y++) {
      for (int x = bitmap_left; x < bitmap_right; x++) {
        if ((_buf->GetRawPtr()[byte_offset] & (1 << bit_offset)) != 0) {
          func(x, y);
        }
        bit_offset--;
        if (bit_offset == -1) {
          bit_offset = 7;
          byte_offset++;
        }
      }
    }
  }
  uint16_t GetMaxw() {
    return _maxw.Get();
  }
  uint16_t GetMaxh() {
    return _maxh.Get();
  }
  uint16_t GetWidth(char32_t c) {
    uint32_t index = _chix.GetIndex(c);
    if (index == 0xFFFFFFFF || _chix.GetStorageFlag(index)) {
      return 0;
    }
    return _data.GetDeviceWidth(_chix.GetOffset(index));
  }
  uint16_t GetAsce() {
    return _asce.Get();
  }
  uint16_t GetDesc() {
    return _desc.Get();
  }
private:
  bool _is_initialized = false;

  class Section {
  public:
    void Load(char *buf) {
      while(true) {
        uint32_t length = be32toh(*(reinterpret_cast<uint32_t *>(buf + 4)));
        if (strncmp(GetSignature(), buf, 4) == 0) {
          LoadSub(buf + 8, length);
          return;
        }
        if (strncmp("DATA", buf, 4) == 0) {
          return;
        }
        buf += 8 + length;
      }
    }
  protected:
    virtual void LoadSub(char *buf, uint32_t length) = 0;
    virtual const char *GetSignature() = 0;
  };

  class Maxw : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXW";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxw;

  class Maxh : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXH";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxh;

  class Chix : public Section {
  public:
    uint32_t GetIndex(uint32_t point) {
      for (uint32_t offset = 0; offset < _len; offset += 9) {
        if (be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset))) == point) {
          return offset;
        }
      }
      return 0xFFFFFFFF;
    }
    uint32_t GetOffset(uint32_t offset) {
      return be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset + 5)));
    }
    bool GetStorageFlag(uint32_t offset) {
      return (_buf[offset + 4] & 0b111 != 0b000);
    }
  private:
    virtual const char *GetSignature() override {
      return "CHIX";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      _len = length;
      _buf = buf;
    }
    char *_buf;
    uint32_t _len;
  } _chix;

  class Asce : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "ASCE";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _asce;

  class Desc : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "DESC";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _desc;
  
  class Data : public Section {
  public:
    uint16_t GetWidth(uint32_t offset) {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset)));
    }
    uint16_t GetHeight(uint32_t offset) {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset + 2)));
    }
    int16_t GetXOffset(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 4)));
    }
    int16_t GetYOffset(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 6)));
    }
    int16_t GetDeviceWidth(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 8)));
    }
    void SetBuffer(char *buf) {
      _buf = buf;
    }
  private:
    virtual const char *GetSignature() override {
      return "DATA";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 0xFFFFFFFF);
    }
    char *_buf;
  } _data;


  uptr<Array<char>> _buf;
};

