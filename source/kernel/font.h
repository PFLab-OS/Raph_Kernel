/*
 *
 * Copyright (c) 2017 Raphine Project
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Author: Liva
 *
 * analyzer for pf2 font file (generated by grub-mkfont)
 * 
 */

#pragma once

#include <assert.h>
#include <string.h>
#include <endian.h>
#include <stdint.h>
#include <function.h>

class Font {
public:
  Font() {
  }
  int Load(char *buf) {
    _buf = buf;
    if (strncmp("FILE", _buf, 4) != 0) {
      return -1;
    }
    if (be32toh(*(reinterpret_cast<uint32_t *>(_buf + 4))) != 4) {
      return -1;
    }
    if (strncmp("PFF2", _buf + 8, 4) != 0) {
      return -1;
    }

    _maxw.Load(_buf + 12);
    _maxh.Load(_buf + 12);
    _ptsz.Load(_buf + 12);
    _data.SetBuffer(_buf);
    _data.Load(_buf + 12);
    _chix.Load(_buf + 12);
    _is_initialized = true;
    return 0;
  }
  void Print(char32_t c, uptr<GenericFunction<bool, int, int>> func) {
    if (!_is_initialized) {
      return;
    }
    _data.Print(_chix.GetOffset(c), func);
  }
  uint16_t GetMaxw() {
    return _maxw.Get();
  }
  uint16_t GetMaxh() {
    return _maxh.Get();
  }
  uint16_t GetWidth(char32_t c) {
    return _data.GetDeviceWidth(_chix.GetOffset(c));
  }
private:
  bool _is_initialized = false;

  class Section {
  public:
    void Load(char *buf) {
      while(true) {
        uint32_t length = be32toh(*(reinterpret_cast<uint32_t *>(buf + 4)));
        if (strncmp(GetSignature(), buf, 4) == 0) {
          LoadSub(buf + 8, length);
          return;
        }
        if (strncmp("DATA", buf, 4) == 0) {
          return;
        }
        buf += 8 + length;
      }
    }
  protected:
    virtual void LoadSub(char *buf, uint32_t length) = 0;
    virtual const char *GetSignature() = 0;
  };

  class Maxw : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXW";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxw;

  class Maxh : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXH";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxh;

  class Ptsz : public Section {
  public:
    uint16_t Get() {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "PTSZ";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _ptsz;

  class Chix : public Section {
  public:
    uint32_t GetOffset(uint32_t point) {
      for (uint32_t offset = 0; offset < _len; offset += 9) {
        if (be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset))) == point) {
          assert((_buf[offset + 4] & 0b111) == 0b000);
          return be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset + 5)));
        }
      }
      return 0xFFFFFFFF;
    }
  private:
    virtual const char *GetSignature() override {
      return "CHIX";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      _len = length;
      _buf = buf;
    }
    char *_buf;
    uint32_t _len;
  } _chix;

  class Data : public Section {
  public:
    uint16_t GetWidth(uint32_t offset) {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset)));
    }
    uint16_t GetHeight(uint32_t offset) {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset + 2)));
    }
    int16_t GetXOffset(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 4)));
    }
    int16_t GetYOffset(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 6)));
    }
    int16_t GetDeviceWidth(uint32_t offset) {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 8)));
    }
    void Print(uint32_t offset, uptr<GenericFunction<bool, int, int>> func) {
      uint32_t byte_offset = offset + 10;
      uint32_t bit_offset = 7;
      int height = GetHeight(offset);
      int width = GetWidth(offset);
      int xoffset = GetXOffset(offset);
      int yoffset = GetYOffset(offset);
      for (int i = 0; i < yoffset; i++) {
        for (int j = 0; j < xoffset + width; j++) {
          func->Execute(false, j, i);
        }
      }
      for (int i = 0; i < height; i++) {
        for (int j = 0; j < xoffset; j++) {
          func->Execute(false, j, i);
        }
        for (int j = 0; j < width; j++) {
          func->Execute((_buf[byte_offset] & (1 << bit_offset)) != 0, j + xoffset, i + yoffset);
          bit_offset--;
          if (bit_offset == -1) {
            bit_offset = 7;
            byte_offset++;
          }
        }
      }
    }
    void SetBuffer(char *buf) {
      _buf = buf;
    }
  private:
    virtual const char *GetSignature() override {
      return "DATA";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 0xFFFFFFFF);
    }
    char *_buf;
  } _data;


  char *_buf = nullptr;
};

