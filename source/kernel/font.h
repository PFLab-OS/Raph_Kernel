/*
 *
 * Copyright (c) 2017 Raphine Project
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Author: Liva
 *
 * analyzer for pf2 font file (generated by grub-mkfont)
 * 
 */

#pragma once

#include <assert.h>
#include <ptr.h>
#include <array.h>
#include <string.h>
#include <endian.h>
#include <stdint.h>
#include <mem/physmem.h>

class Font {
public:
  Font() {
  }
  int Load(uptr<Array<uint8_t>> buf, size_t len);
  void Print(uint32_t index, void (*func)(bool f, int x, int y));
  void GetData(char32_t c, int &width, bool *byte);
  uint16_t GetMaxw() const {
    return _maxw.Get();
  }
  uint16_t GetMaxh() const {
    return _maxh.Get();
  }
  uint32_t GetIndex(char32_t c) const {
    return _chix.GetIndex(c);
  }
  uint16_t GetWidth(char32_t c) const {
    uint32_t index = _chix.GetIndex(c);
    return GetWidth(index);
  }
  uint16_t GetWidth(uint32_t index) const {
    if (index == 0xFFFFFFFF || _chix.GetStorageFlag(index)) {
      return 0;
    }
    return _data.GetDeviceWidth(_chix.GetOffset(index));
  }
  uint16_t GetAsce() const {
    return _asce.Get();
  }
  uint16_t GetDesc() const {
    return _desc.Get();
  }
private:
  bool _is_initialized = false;

  class Section {
  public:
    void Load(char *buf) {
      while(true) {
        uint32_t length = be32toh(*(reinterpret_cast<uint32_t *>(buf + 4)));
        if (strncmp(GetSignature(), buf, 4) == 0) {
          LoadSub(buf + 8, length);
          return;
        }
        if (strncmp("DATA", buf, 4) == 0) {
          return;
        }
        buf += 8 + length;
      }
    }
  protected:
    virtual void LoadSub(char *buf, uint32_t length) = 0;
    virtual const char *GetSignature() = 0;
  };

  class Maxw : public Section {
  public:
    uint16_t Get() const {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXW";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxw;

  class Maxh : public Section {
  public:
    uint16_t Get() const {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "MAXH";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _maxh;

  class Chix : public Section {
  public:
    uint32_t GetIndex(uint32_t point) const {
      for (uint32_t offset = 0; offset < _len; offset += 9) {
        if (be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset))) == point) {
          return offset;
        }
      }
      return 0xFFFFFFFF;
    }
    uint32_t GetOffset(uint32_t offset) const {
      return be32toh(*(reinterpret_cast<uint32_t *>(_buf + offset + 5)));
    }
    bool GetStorageFlag(uint32_t offset) const {
      return (_buf[offset + 4] & 0b111 != 0b000);
    }
  private:
    virtual const char *GetSignature() override {
      return "CHIX";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      _len = length;
      _buf = buf;
    }
    char *_buf;
    uint32_t _len;
  } _chix;

  class Asce : public Section {
  public:
    uint16_t Get() const {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "ASCE";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _asce;

  class Desc : public Section {
  public:
    uint16_t Get() const {
      return _value;
    }
  private:
    virtual const char *GetSignature() override {
      return "DESC";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 2);
      _value = be16toh(*(reinterpret_cast<uint16_t *>(buf)));
    }
    uint16_t _value;
  } _desc;
  
  class Data : public Section {
  public:
    uint16_t GetWidth(uint32_t offset) const {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset)));
    }
    uint16_t GetHeight(uint32_t offset) const {
      return be16toh(*(reinterpret_cast<uint16_t *>(_buf + offset + 2)));
    }
    int16_t GetXOffset(uint32_t offset) const {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 4)));
    }
    int16_t GetYOffset(uint32_t offset) const {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 6)));
    }
    int16_t GetDeviceWidth(uint32_t offset) const {
      return be16toh(*(reinterpret_cast<int16_t *>(_buf + offset + 8)));
    }
    void SetBuffer(char *buf) {
      _buf = buf;
    }
  private:
    virtual const char *GetSignature() override {
      return "DATA";
    }
    virtual void LoadSub(char *buf, uint32_t length) override {
      assert(length == 0xFFFFFFFF);
    }
    char *_buf;
  } _data;


  uptr<Array<char>> _buf;
};

