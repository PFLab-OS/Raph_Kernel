/*
 *
 * Copyright (c) 2017 Raphine Project
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Author: Liva
 *
 * analyzer for pf2 font file (generated by grub-mkfont)
 * 
 */

#include "font.h"
#include <global.h>

int Font::Load(uptr<Array<uint8_t>> buf, size_t len) {
  _buf = buf;
  char *_buf_ptr = _buf->GetRawPtr();
  
  if (strncmp("FILE", _buf_ptr, 4) != 0) {
    return -1;
  }
  if (be32toh(*(reinterpret_cast<uint32_t *>(_buf_ptr + 4))) != 4) {
    return -1;
  }
  if (strncmp("PFF2", _buf_ptr + 8, 4) != 0) {
    return -1;
  }

  _maxw.Load(_buf_ptr + 12);
  _maxh.Load(_buf_ptr + 12);

  _data.SetBuffer(_buf_ptr);
  _data.Load(_buf_ptr + 12);

  _chix.Load(_buf_ptr + 12);
  _asce.Load(_buf_ptr + 12);
  _desc.Load(_buf_ptr + 12);
  _is_initialized = true;

  return 0;
}

void Font::GetData(char32_t c, int &width, bool *data) {
  // return width of character into width
  if (!_is_initialized) {
    return;
  }

  uint32_t index = _chix.GetIndex(c);
  if (index == 0xFFFFFFFF || _chix.GetStorageFlag(index)) {
    return;
  }
  uint32_t offset = _chix.GetOffset(index);
  int maxh = _maxh.Get();
    
  uint32_t data_offset = offset + 10;
  uint32_t bit_offset = 7;
  int bitmap_bottom = _asce.Get() - _data.GetYOffset(offset);
  int bitmap_top = bitmap_bottom - _data.GetHeight(offset);
  int bitmap_left = _data.GetXOffset(offset);
  int bitmap_right = _data.GetXOffset(offset) + _data.GetWidth(offset);
  width = _data.GetDeviceWidth(offset);
  
  for (int y = 0; y < bitmap_top; y++) {
    for (int x = 0; x < width; x++) {
      data[y * width + x] = false;
    }
  }
  for (int y = bitmap_top; y < bitmap_bottom; y++) {
    for (int x = 0; x < bitmap_left; x++) {
      data[y * width + x] = false;
    }
    for (int x = bitmap_left; x < bitmap_right; x++) {
      data[y * width + x] = (_buf->GetRawPtr()[data_offset] & (1 << bit_offset)) != 0;
      bit_offset--;
      if (bit_offset == -1) {
        bit_offset = 7;
        data_offset++;
      }
    }
    for (int x = bitmap_right; x < width; x++) {
      data[y * width + x] = false;
    }
  }
  for (int y = bitmap_bottom; y < maxh; y++) {
    for (int x = 0; x < width; x++) {
      data[y * width + x] = false;
    }
  }
}

void Font::GetPixels(char32_t c, int bytesPerPixel, int xsize, 
   uint8_t *data, int &width, uint8_t *foreColor, uint8_t *backColor)
{
  bool bData[GetMaxw() * GetMaxh()];

  GetData(c, width, bData);
  for(int y = 0; y < GetMaxh(); y++){
    for(int x = 0; x < GetMaxw(); x++){
      for(int i = 0; i < bytesPerPixel; i++){
        data[(xsize * y + x) * bytesPerPixel + i] =
          bData[width * y + x] ? foreColor[i] : backColor[i];
      }
    }
  }
}

void Font::Print(uint32_t index, void (*func)(bool f, int x, int y)) {
  if (!_is_initialized) {
    return;
  }

  if (index == 0xFFFFFFFF || _chix.GetStorageFlag(index)) {
    return;
  }
  uint32_t offset = _chix.GetOffset(index);
  int maxh = _maxh.Get();
    
  uint32_t byte_offset = offset + 10;
  uint32_t bit_offset = 7;
  int bitmap_bottom = _asce.Get() - _data.GetYOffset(offset);
  int bitmap_top = bitmap_bottom - _data.GetHeight(offset);
  int bitmap_left = _data.GetXOffset(offset);
  int bitmap_right = _data.GetXOffset(offset) + _data.GetWidth(offset);
  int width = _data.GetDeviceWidth(offset);

  for (int y = 0; y < bitmap_top; y++) {
    for (int x = 0; x < width; x++) {
      func(false, x, y);
    }
  }
  for (int y = bitmap_top; y < bitmap_bottom; y++) {
    for (int x = 0; x < bitmap_left; x++) {
      func(false, x, y);
    }
    for (int x = bitmap_left; x < bitmap_right; x++) {
      func((_buf->GetRawPtr()[byte_offset] & (1 << bit_offset)) != 0, x, y);
      bit_offset--;
      if (bit_offset == -1) {
        bit_offset = 7;
        byte_offset++;
      }
    }
    for (int x = bitmap_right; x < width; x++) {
      func(false, x, y);
    }
  }
  for (int y = bitmap_bottom; y < maxh; y++) {
    for (int x = 0; x < width; x++) {
      func(false, x, y);
    }
  }
}
